# 3-1 마이크로서비스 아키텍처 IPC 개요

### 1️⃣ 상호 작용 스타일

상호 작용 스타일의 선택은 전체 애플리케이션의 가용성에 영향을 끼치며 접합한 통합 테스트 전략을 수립하는 데에 도움을 준다.

클라이언트/서비스 상호 작용 스타일은 두 가지 기준으로 분류할 수 있다.

1. 일대일/일대다 여부
    1. 일대일: 각 클라이언트 요청은 정확히 한 서비스가 처리한다.
    2. 일대다: 각 클라이언트요청을 여러 서비스가 협동하여 처리한다.
2. 동기/비동기 여부
    1. 동기: 클라이언트는 서비스가 제시간에 응답하리라 기대하고 대기 도중 블로킹을 할 수 있다.
    2. 비동기: 클라이언트가 블로킹하지 않는다. 응답은 즉시 전송되지 않아도 된다.

![image](https://user-images.githubusercontent.com/89118999/185819639-8a6346c9-7166-4383-b6ce-b0e487cbbbcf.png)

- **일대일 상호 작용**

**요청/응답**: 클라이언트는 서비스에 요청하고 응답을 기다린다. 클라이언트는 응답이 제때 도착하리라 기대하고 대기 도중 블로킹할 수 있다. 서비스가 서로 강하게 결합되는 상호 작용 스타일이다.

**비동기 요청/응답**: 클라이언트는 서비스에 요청을 하고 서비스는 비동기적으로 응답한다. 클라이언트는 대기 중에 블로킹하지 않고, 서비스는 오랫동안 응답하지 않을 수 있다.

**단방향 알림**: 클라이언트는 서비스에 일방적으로 요청하지만 서비스는 응답하지 않는다.

- **일대다 상호 작용**

**발행/구독**: 클라이언트는 알림 메시지를 발행하고 여기에 관심 있는 0개 이상의 서비스가 메시지를 소비한다.

**발행/비동기 응답**: 클라이언트는 요청 메시지를 발행하고 주어진 시간동안 관련 서비스가 응답하길 기다린다.

### 2️⃣ API 발전시키기

- **시맨틱 버저닝**

시맨틱 버저닝 명세는 API 버저닝에 관한 유용한 지침서이다. 

버전 번호를 사용하고 증가시키는 규칙들이 명시되어 있다.

버전 번호를 세 파트로 구성하고 다음 규칙을 따라 증가시킨다.

1. **MAJOR**: 하위 호환되지 않는 변경분을 API에 적용 시
2. **MINOR**: 하위 호환되는 변경분을 API에 적용시
3. **PATCH**: 하위 호환되는 오류 수정 시

REST API 라면 메이저 버전을 URL 경로의 첫번째 엘리먼트로 쓸 수 있다.

메시징 기반의 서비스라면 이 서비스가 발행한 메시지에 버전 번호를 쓸 수 있다.

- **하위 호환되는 소규모 변경**

변경을 하더라도 가급적 하위 호환성을 보장해야 한다.

1. 옵션 속성을 요청에 추가
2. 속성을 응답에 추가
3. 새 작업을 추가

이런 종류의 변경은 새 서비스에 적용해도 기존 클라이언트 역시 별 문제없이 동작한다.

> **견고성 원칙**                                                                                                                                  당신이 하는 일은 보수적으로 다른 사람들이 하는 일은 관대하게 바라보라
> 

요청 속성이 누락되어도 서비스는 기본값을 제공하고, 서비스가 필요한 것보다 더 많은 속성을 응답하더라도 클라이언트는 간단히 무시해야 한다.

클라이언트/서비스가 견고성 원칙을 뒷받침하는 요청/응답 포맷을 사용하면 매끄럽게 진행된다.

- **중대한 대규모 변경**

매우 중요한, 기존 버전과 호환이 안 되는 변경을 API에 적용해야 할 때가 있다.

일정 기간 동안 신/구 번전 API를 모두 지원해야 한다. 

HTTP 기반의 REST API는 URL에 메이저 버전 번호를 삽입할 수 있다.(/v1, /v2)

```basic
GET /orders/xyz HTTP/1.1
Accept: application/vnd.example.resource+json; version=1
```

Accept 뒤에 버전을 넣을 수 있다.

여러 버전을 지원하려면 API가 구현된 서비스 어댑터에 신/구 버전을 중계하는 로직이 필요하다.

API 게이트웨이는 반드시 버저닝된  API를 사용하며, 구버전 API도 여러 버전을 지원해야 한다.

### 3️⃣ 메시지 포맷

IPC의 핵심은 메시지 교환이다. 

메시징이나 HTTP 프로토콜을 사용하려면 메시징 포맷을 선택해야 한다.(gRPC 같은 IPC는 메시지 포맷이 정해져 있다.)

메시지 포맷은 크게 텍스트와 이진 포맷으로 나뉜다.

- **텍스트 메시지 포맷(JSON, XML)**

**장점**: 사람이 읽을 수 있고 자기 서술적 장점이 있다. 

JSON 메시지: 네임드 프로퍼티(이름을 가진 프로퍼티)

XML 메시지: 네임드 엘리먼트와 그 값을 모아 놓은 구조

메시지 컨슈머: 자신이 관심 있는 값만 골라 쓰고 나머지는 무시한다. 메시지 스키마가 자주 바뀌어도 하위 호환성은 쉽게 보장된다.

**단점**: 메시지가 다소 길다. 모든 메시지에 속성값 이외에 속성명이 추가되는 오버헤드가 있고, 덩치가 큰 메시지는 텍스트를 파싱하는 오버헤드도 있다. 

효율/성능이 중요한 경우 이진 포맷을 고려해볼 필요가 있다.

- **이진 메시지 포맷**

프로토콜 버퍼와 아브로가 유명하다. 메시지 구조 정의에 필요한 타입 IDL을 제공하고 컴파일러는 메시지를 직렬화/역직렬화하는 코드를 생성한다. 

→ 서비스를 API 우선 접근 방식으로 설계할 수 밖에 없다.

아브로 컨슈머는 스키마를 알고 있어야 메시지를 해석할 수 있다. API 발전 측면에서는 프로토콜 버퍼가 더 용이하다.
