# **2-1 마이크로서비스 아키텍쳐란 무엇인가?**

> 마이크로서비스 아키텍쳐는 관리성, 테스트성, 배포성이 높은 애플리케이션을 구축하는 아키텍쳐 스타일이다.
> 

### **1️⃣ 소프트웨어 아키텍처의 정의와 중요성**

렌 바스와 그가 이끄는 소프트웨어 공학 연구소 직원들은 소프트웨어 아키텍쳐를 이렇게 정의했다.

> 컴퓨팅 시스템의 소프트웨어 아키텍쳐는 소프트웨어 엘리먼트와 그들 간의 관계, 그리고 이 둘의 속성으로 구성된 시스템을 추론하는데 필요한 구조의 집합이다.
> 

핵심은 애플리케이션 아키텍쳐가 여러 파트로의 분해와 이런 파트 간의 관계(연관성)라는 것이다.

- **분해가 중요한 이유**

업무와 지식을 분리한다. 덕분에 전문 지식을 보유한 사람들이 함께 생산적으로 애플리케이션 작업을 할 수 있다.

소프트웨어 엘리먼트가 어떻게 상호작용하는지 알 수 있다.

- **소프트웨어 아키텍처의 4+1 뷰 모델**

필립 크러첸은 소프트웨어 아키텍처가 4+1 뷰 모델이라고 기술한 논문을 발표하였다.

4+1 모델은 소프트웨어 아키텍처를 바라보는 상이한 4뷰를 정의한다. 각 뷰는 아키텍처의 특정한 측면을 기술하고 특정 소프트웨어 엘리먼트와 그들 사이의 관계로 구성된다.

 

1. 논리 뷰: 개발자가 작성한 소프트웨어 엘리먼트, 객체 지향 언어라면 클래스, 패키지의 관계를 의미한다. (상속, 연관, 의존)
2. 규현 뷰: 빌드 시스템의 결과물, 모듈과 컴포넌트(하나 이상의 모듈로 구성된 실행/배포 가능 단위)로 구성된다. 자바에서 모듈은 보통 JAR 파일, 컴포넌트는 WAR 파일이나 실행 가능한 JAR 파일이다. 모듈 간 디펜던시와 컴포넌트/모듈 간 조합관계도 포함된다.
3. 프로세스 뷰: 런타임 컴포넌트, 각 엘리먼트는 개별 프로세스고, IPC는 프로세스 간 관계를 나타낸다.
4. 배포 뷰: 프로세스가 머신에 매핑되는 방법, 이 뷰의 엘리먼트는 머신 및 프로세스고 머신 간의 관계가 바로 네트워킹이다. 프로세스와 머신 사이의 관계도 포함된다.

![image](https://user-images.githubusercontent.com/89118999/185206407-f3c3bc99-4ae1-49b7-bfe1-a44718dfb539.png)

4뷰 외에도 뷰를 구동시키는 시나리오가 있다. 각 시나리오는 특정 뷰 내에서 얼마나 다양한 아키텍처 요소가 협동하여 요청을 처리하는지 기술한다. 

가령 논리 뷰의 시나리오는 클래스가 협동하는 방법을, 프로세스 뷰의 시나리오는 프로세스가 서로 어떻게 협동하는지 나타낸다.

- **아키텍처의 중요성**

애플리케이션 요건은 크게 두 가지로 나뉜다. 

1. 애플리케이션이 해야 할 일을 정의한 기능 요건이다. 보통 유스 케이스나 사용자 스토리 포맷으로 기술하는데, 이 기능 요건과 아키텍처는 무관하다. 기능 요건은 어느 아키텍처든 구현할 수 있다.
2. ‘~성’으로 끝나는 서비스 품질 요건이다. 아키텍처는 바로 이 요건을 충족시킬 수 있게 설계해야 하므로 아주 중요하다.

### 2️⃣ 아키텍처 스타일 개요

소프트웨어 아키텍처 지식 체계의 선구자인 데이비드 갈란과 메리 쇼는 아키텍처 스타일을 이렇게 정의했다.

> 아키텍처 스타일은 체계적인 조직의 관점에서 시스템 군을 정의한다. 구체적으로 말하면, 아키텍처 스타일은 그 스타일로 만든 인스턴스에서 사용 가능한 컴포넌트와 커넥터의 보케블러리 그리고 이들을 조합할 수 있는 제약 조건을 결정한다.
> 

특정 아키텍처 스타일은 엘리먼트와 관계의 한정된 팔레트(사용 가능한 범위)를 제공하며, 이를 토대로 애플리케이션 아키텍처의 뷰를 정의할 수 있다. 

- **계층화 아키텍처 스타일**

계층마다 명확히 정의된 역할을 분담하며, 계층 간 디펜던시는 아키텍처로 제한한다. 따라서 계층은 바로 하위에 있는 계층에만 의존하거나, 하위에 위치한 어느 한 계층에 의존한다. 

1. 표현 계층: 사용자 인터페이스 또는 외부 API가 구현된 계층
2. 비즈니스 로직 계층: 비즈니스 로직이 구현된 계층
3. 영속화 계층: DB 상호 작용 로직이 구현된 계층

계층화 아키텍처는 몇 가지 흠이있다.

1. 표현 계층이 하나뿐이다. 
2. 영속화 계층이 하나뿐이다. 
3. 비즈니스 로직 계층을 영속화 계층에 의존하는 형태로 정의한다. 

계층화 아키텍처는 잘 설계된 애플리케이션에서 디펜던시를 잘못 나타내는 문제도 있다. 비즈니스 로직 계층은 인터페이스나 데이터 접근 메서드가 정의된 인터페이스 리포지토리를 정의하고, 영속화 계층은 리포지토리 인터페이스를 구현한 DAO 클래스를 정의한다. 

결국 실제 디펜던시가 계층화 아키텍처에 기술된 것과 정반대이다.

- **육각형 아키텍처**

애플리케이션에 표현 계층대신 비즈니스 로직을 호출하여 외부에서 들어온 요청을 처리하는 인바운드 어댑터와 영속화 계층 대신 비즈니스 로직에 의해 호출되고 외부 애플리케이션을 호출하는 아웃바운드 어댑터를 둔다. 

비즈니스 로직이 어댑터에 전혀 의존하지 않는 것이 가장 중요한 장점이다. 

**인바운드 포트**는 비즈니스 로직이 표출된 API로서, 외부 애플리케이션은 이 API를 통해 비즈니스 로직을 호출한다. 

**아웃바운드 포트**는 비즈니스 로직이 외부 시스템을 호출하는 방법에 관한 것이다.

**인바운드 어댑터**는 외부에서 들어온 요청을 인바운드 포트를 호출,처리한다.(스프링 MVC 컨트롤러)

**아웃바운드 어댑터**는 비즈니스 로직에서 들어온 요청을 외부 애플리케이션/서비스를 호출해 처리한다.(DAO 클래스, 프록시 클래스)

![image](https://user-images.githubusercontent.com/89118999/185206621-4170f6e6-b11d-4405-8532-f7fdf86a5a42.png)

### 2️⃣ **마이크로서비스 아키텍처는 일종의 아키텍처 스타일이다.**

마이크로서비스 아키텍처의 핵심 제약 조건은 서비스를 느슨하게 결합한다는 것이다.

- **서비스란?**

서비스란 어떤 기능이 구현되어 단독 배포가 가능한 소프트웨어 컴포넌트이다. 서비스 작업은 크게 커맨드(명령/CUD)와 쿼리(조회/R)로 나뉜다. 

- **느슨한 결합**

서비스는 구현된 코드를 감싼 API를 통해서만 상호 작용하므로 클라이언트에게 영향을 끼치지 않고, 서비스 내부 구현 코드를 바꿀 수 있다. 

API를 통해서만 동작하기 때문에 직접 DB와 통신할 수 없다.

서비스의 영속적 데이터는 반드시 프라이빗으로 유지해야 한다. DB테이블을 서로 공유하지 않기 때문에 런타임 격리도 향상된다.

다른 서비스를 블로킹하는 일 자체가 불가능하다.

- **공유 라이브러리의 역할**

코드 중복을 방지하기 위해 재사용 가능한 기능을 라이브러리로 패키징하는 것은 당연한 일이다.

의도치 않은 서비스간 결합도를 유발하지 않도록 주의해야 한다.


- **서비스 규모는 별로 중요하지 않다**
