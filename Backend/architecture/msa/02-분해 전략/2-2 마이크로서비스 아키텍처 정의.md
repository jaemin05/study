# 2-2 마이크로서비스 아키텍처 정의

![image](https://user-images.githubusercontent.com/89118999/185355512-8168f2c9-78a9-4559-9335-e49514c7e9e5.png)

**아키텍처를 정의하는 1단계**: 애플리케이션 요건을 핵심 요청으로 추출한다. 

**2단계**: 어떻게 여러 서비스로 분해할지 결정하는 것이다. 

**3단계**: 서비스별로 API를 정의한다. 이를 위해서는 1단계에서 식별된 시스템 작업을 각 서비스에 배정해야 한다. 

분해 과정에는 장애물이 많다. 

1. 네트워크 지연, 서비스 간 왕복이 너무 잦아 실제로 분해할 수 없는 경우도 있다.
2. 서비스 간 동기 통신으로 인해 가용성이 떨어진다. 해결책은 자기 완비형 서비스 개념이다. 
3. 여러 서비스에 걸쳐 데이터 일관성을 지키는 요건이다. 사가로 해결한다.
4. 애플리케이션 도처에 숨어 있는 만능 클래스이다. 이런 클래스는 DDD개념을 활용하면 제거할 수있다.

### 1️⃣ 시스템 작업 식별

애플리케이션 아키텍처를 정의하는 첫 단추는 시스템 작업을 정의하는 일이다. 그 출발점은 사용자 스토리와 이와 관련된 사용자 시나리오 등의 애플리케이션 요건이다. 

![image](https://user-images.githubusercontent.com/89118999/185355580-cc6069d2-0783-4e25-b7e8-125fb818dad0.png)

 도메인 모델은 주로 사용자 스토리의 명사에서 도출한다. 

시스템 작업은 주로 동사에서 도출한다. 각각 하나 이상의 도메인 객체와 그들 간의 관계로 기술한다.  (도메인 모델을 생성,수정,삭제하거나 모델 간 관계를 맺고 끊을 수있다.)

- **시스템 작업 정의**

시스템 작업은 크게 두 종류로 나뉜다.

1. 커맨드: 데이터 생성, 수정, 삭제
2. 쿼리: 데이터 읽기

### 2️⃣ 서비스 정의: 비즈니스 능력 패턴별 분해

마이크로서비스 아키텍처를 구축하는 첫 번째 전략은 비즈니스 능력에 따라 분해하는 것이다. 비즈니스 아키텍처 모델링에서 비롯된 비즈니스 능력은 비즈니스가 가치를 생산하기 위해하는 일을 말한다. 

![image](https://user-images.githubusercontent.com/89118999/185355653-e6cd91fd-0e33-420f-a306-28160459bb4d.png)

그림 2-8에 스케치한 서비스는 아키텍처를 정의한 첫 번째 버전에 불과하다. 

아키텍처를 정의하는 과정에서는 각각의 핵심 아키텍처 서비스와 나머지 서비스가 어떻게 협동하는지 살피는 과정이 중요하다. 

### 3️⃣ 서비스 정의: 하위 도메인 패턴별 분해

DDD는 도메인을 구성하는 각 하위 도메인마다 도메인 모델을 따로 정의한다. 

**경계 컨텍스트**: 도메일 모델의 범위

![image](https://user-images.githubusercontent.com/89118999/185355710-ee1396c8-87b4-4181-9468-0a39123c1fa6.png)

DDD와 마이크로서비스 아키텍처는 찰떡궁합이다. DDD의 하위 도메인, 경계 컨텍스트 개념은 마이크로서비스 아키텍처의 서비스와 잘맞고, 마이크로서비스 아키텍처의 서비스 자율팀 개념은 도메인 모델을 개념 팀이 소유/개발한다는 DDD 사고방식과 어울린다.

### 3️⃣ 분해 지침

- **단일 책임 원칙**

> 클래스는 오직 하나의 변경 사유를 가져야 한다.
> 

오직 하나의 클래스를 정의하라는 것이다. (마이크로서비스 아키텍처에 적용하면 하나의 책임만 가진 작고 응집된 서비스를 정의할 수있다.

- **공동 폐쇠 원칙**(**C**ommon **C**losure **P**rinciple)

> 패키지의 클래스들은 동일한 유형의 변경에 대해 닫혀 있어야 한다. 패키지에 영향을 주는 변경은 그 패키지에 속한 모든 클래스에 영향을 끼친다.
> 

어떤 두 클래스가 동일한 사유로 맞물려 변경되면 동일한 패키지에 있어야 한다.

요견이 바뀌어도 수정/배포할 서비스 개수가 줄어든다.
